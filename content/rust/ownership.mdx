---
title: 所有権とは？
order: 2
description: Rustの最重要概念の1つである所有権について学びます
---

# 所有権とは？

## 概要

このセクションでは、Rustの最重要概念の1つである**所有権（ownership）**について学びます。  
所有権は、Rustが**ガーベジコレクタなしでメモリ安全性を保証する仕組み**の土台となっています。

公式な詳しい解説は、Rust公式本日本語版の「[4.1. 所有権とは？](https://doc.rust-jp.rs/book-ja/ch04-01-what-is-ownership.html)」にあります。

## 解説

### 所有権の3つのルール

Rustの所有権には、次の3つの基本ルールがあります（参考: [The Rust Programming Language 日本語版](https://doc.rust-jp.rs/book-ja/)）。

1. **Rustの各値には所有者と呼ばれる変数が一つ存在する。**
2. **同時に存在できる所有者はただ一つ。**
3. **所有者がスコープから外れたとき、その値は破棄される。**

これらのルールにより、「いつメモリを確保し、いつ解放するか」がコンパイル時に決まります。

### ムーブ（所有権の移動）

`String` 型のような所有権を持つ値を**別の変数に代入**すると、所有権は**ムーブ（move）**されます。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // 所有権が s1 から s2 に移動（ムーブ）

    // println!("{}", s1); // コンパイルエラー: ここでは s1 はもう使えない
    println!("{}", s2);     // OK
}
```

`s1` から `s2` へ所有権が移ったため、`s1` はもはや有効ではありません。  
これにより、同じメモリを2つの変数が同時に解放してしまうようなバグを防ぎます。

### クローン（データを複製する）

もし**同じ内容を2つの変数で独立して持ちたい**場合は、`clone` メソッドでデータを複製します。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone(); // データをヒープ上で複製

    println!("s1 = {}, s2 = {}", s1, s2); // 両方とも使用可能
}
```

`clone` は実際にメモリ上のデータをコピーするので、その分コストがかかる可能性があります。  
必要なときだけ使うようにしましょう。

### コピー型（Copyトレイト）

整数型（`i32` など）や浮動小数点数型（`f64` など）のような**小さくて固定サイズの値**は、`Copy` トレイトが実装されているため、代入時にムーブではなく**コピー**されます。

```rust
fn main() {
    let x = 5;   // i32 は Copy
    let y = x;   // x の値がコピーされる

    println!("x = {}, y = {}", x, y); // x も y も使える
}
```

## 例

所有権の動きを意識しながら、関数に値を渡す例を見てみましょう。

```rust
fn main() {
    let s = String::from("Rust");
    takes_ownership(s);   // ここで s の所有権がムーブされる
    // println!("{}", s); // ここでは s はもう使えない（コンパイルエラー）

    let x = 10;
    makes_copy(x);        // x は Copy 型なので、その後も使える
    println!("x はまだ使えます: {}", x);
}

fn takes_ownership(s: String) {
    println!("受け取った文字列: {}", s);
} // ここで s がスコープを抜け、String のメモリが解放される

fn makes_copy(x: i32) {
    println!("受け取った数値: {}", x);
} // x は Copy なので、呼び出し元の x には影響しない
```

ポイント:

- 関数に `String` を渡すと、**所有権も一緒に移動**する。
- `i32` のような `Copy` 型は、関数に渡しても呼び出し元で引き続き利用できる。

## 確認問題

<Quiz
  questions={[
    {
      question: "次のコードについて正しい説明はどれですか？\n\nlet s1 = String::from(\"hello\");\nlet s2 = s1;",
      options: [
        "s1 と s2 は両方とも同じ文字列を共有し、どちらかがスコープを抜けるともう一方も無効になる",
        "s1 の所有権が s2 にムーブされ、以降 s1 は使えない",
        "s1 と s2 の両方が独立した文字列を持つ（クローンされる）",
        "コンパイルエラーになる"
      ],
      correctAnswer: 1,
      explanation: "代入により所有権がムーブされるため、s1 は無効になり s2 だけが有効になります。"
    },
    {
      question: "次のコードはコンパイルできますか？\n\nlet x = 5;\nlet y = x;\nprintln!(\"x = {}\", x);",
      options: [
        "コンパイルできる。x は Copy 型なので y に代入しても引き続き使える",
        "コンパイルエラー。x の所有権が y にムーブされるため x は使えない",
        "実行時エラーになる",
        "警告は出るがコンパイルできる"
      ],
      correctAnswer: 0,
      explanation: "i32 は Copy トレイトを実装しているため、代入でムーブではなくコピーが行われます。"
    },
    {
      question: "所有権の主な目的として最も適切なのはどれですか？",
      options: [
        "プログラムの実行速度を常に最大化するため",
        "ガーベジコレクタなしでメモリの安全性を保証するため",
        "マルチスレッドプログラミングを禁止するため",
        "Rustコードを他言語に変換しやすくするため"
      ],
      correctAnswer: 1,
      explanation: "所有権システムは、コンパイル時にメモリのライフタイムを管理し、ガーベジコレクタなしで安全性を確保するための仕組みです。"
    }
  ]}
/>


